# -*- coding: utf-8 -*-
"""cadim pneumonia pna RAUNET

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_rjmMTLespZytwl5bFMe-ao7lI--OzeQ
"""

# Commented out IPython magic to ensure Python compatibility.
# % pip install -q jarvis-md
# % pip install -q tensorflow-model-optimizationpi 

import os
import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import optimizers, losses
from tensorflow.keras import Input
#import tensorflow_addons as tfa
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

from jarvis.train import datasets, custom
from jarvis.train.client import Client
from jarvis.utils.general import overload, tools as jtools
from jarvis.utils.db import DB
from model import *

datasets.download(name='ct/pna')

@overload(Client)
def preprocess(self, arrays, **kwargs):   
    msk = np.zeros(arrays['ys']['pna'].shape)
    msk[arrays['xs']['lng'] > 0] = 1
    arrays['xs']['dat'] *= arrays['xs']['lng']
    #arrays['xs']['msk'] = msk 
    arrays['ys']['pna'] = arrays['ys']['pna'] > 0
    return arrays


path = '{}\\data\\ymls\\client.yml'.format(jtools.get_paths('ct/pna')['code'])
client = Client('./client.yml')
gen_train, gen_valid = client.create_generators()
inputs = client.get_inputs(Input)


def sce(weights=None, scale=1.0):
    loss = losses.SparseCategoricalCrossentropy(from_logits=True)
    def sce(y_true, y_pred):
        return loss(y_true=y_true, y_pred=y_pred, sample_weight=weights) * scale
    return sce

def dsc_soft(weights=None, scale=1.0, epsilon=0.01, cls=1):
    def calc_dsc(y_true, y_pred):
        true = tf.cast(y_true[..., 0] == cls, tf.float32)
        pred = tf.nn.softmax(y_pred, axis=-1)[..., cls]
        if weights is not None:
            true = true * (weights[..., 0]) 
            pred = pred * (weights[..., 0])
        A = tf.math.reduce_sum(true * pred) * 2
        B = tf.math.reduce_sum(true) + tf.math.reduce_sum(pred) + epsilon
        return (1 - (A / B)) * scale
    return calc_dsc

def happy_meal(alpha = 5, beta = 1, weights=None, epsilon=0.01, cls=1):
    l1 = dsc_soft(weights, beta, epsilon, cls)
    l2 = sce(weights, alpha)
    def calc_loss(y_true, y_pred):
        return l2(y_true, y_pred) + l1(y_true, y_pred)
    return calc_loss

def train():    
    model_checkpoint_callback = tf.keras.callbacks.ModelCheckpoint(
        filepath='./ckp/',
        save_weights_only=True,
        monitor='val_accuracy',
        mode='max',
        save_best_only=True
    )

    tensorboard_callback = tf.keras.callbacks.TensorBoard(
        log_dir="./logs", 
        histogram_freq=1,
        write_images=True,
        write_graph=False
    )

    model = RA_UNET(inputs)
    model.compile(
        optimizer=optimizers.Adam(learning_rate=2e-4, beta_1=0.9, beta_2=0.999, epsilon=1e-08, decay=0.0),
        loss={
            'pna': happy_meal(1.5, 1)
            },
        metrics={
            'pna': ['accuracy', custom.dsc()]
            }        
    )

    model.fit(
        x=gen_train,
        epochs=100,
        steps_per_epoch=600,
        validation_data=gen_valid,
        validation_steps=500,
        validation_freq=1,
        callbacks=[tensorboard_callback, model_checkpoint_callback]
    )


def test(model):
    lung_seg = []
    for x,y in test_valid:
        logits = model.predict(x)
        if type(logits) is dict:
            logits = logits['pna'] 
        lung_seg.append(dice(y['pna'][0], logits[0]))
    
    lung_seg = np.array(lung_seg)
    print(lung_seg.mean())
    
if __name__ == "__main__":
    train()
    pass
    


    
